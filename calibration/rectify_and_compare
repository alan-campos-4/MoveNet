import cv2
import numpy as np
from pipeline import gstreamer_pipeline

# --- Stereo Calibration Parameters ---
data = np.load("calib/stereo_params.npz")
mtx_l, dist_l = data["mtx_l"], data["dist_l"]
mtx_r, dist_r = data["mtx_r"], data["dist_r"]
map1_l, map2_l = data["map1_l"], data["map2_l"]
map1_r, map2_r = data["map1_r"], data["map2_r"]

# Chessboard dimensions for homography
BOARD_W, BOARD_H = 9, 6      # inner corners (10Ã—7 squares board)
SQUARE_PX = 50               # output square size in pixels for homography view

# Build undistort-only maps (R=I, P=intrinsic)
h, w = map1_l.shape[:2]
mapu_l1, mapu_l2 = cv2.initUndistortRectifyMap(
    mtx_l, dist_l, np.eye(3), mtx_l, (w, h), cv2.CV_16SC2
)
mapu_r1, mapu_r2 = cv2.initUndistortRectifyMap(
    mtx_r, dist_r, np.eye(3), mtx_r, (w, h), cv2.CV_16SC2
)

# Open CSI cameras
capL = cv2.VideoCapture(gstreamer_pipeline(0), cv2.CAP_GSTREAMER)
capR = cv2.VideoCapture(gstreamer_pipeline(1), cv2.CAP_GSTREAMER)
if not (capL.isOpened() and capR.isOpened()):
    raise RuntimeError("Cannot open CSI cameras")

while True:
    retL, frameL = capL.read()
    retR, frameR = capR.read()
    if not (retL and retR):
        break

    # 1) Undistort (preserve original perspective)
    undistL = cv2.remap(frameL, mapu_l1, mapu_l2, cv2.INTER_LINEAR)
    undistR = cv2.remap(frameR, mapu_r1, mapu_r2, cv2.INTER_LINEAR)

    # 2) Stereo rectify (epipolar alignment)
    rectL = cv2.remap(frameL, map1_l, map2_l, cv2.INTER_LINEAR)
    rectR = cv2.remap(frameR, map1_r, map2_r, cv2.INTER_LINEAR)

    # 3) Homography warp of left undistorted to fronto-parallel
    grayL = cv2.cvtColor(undistL, cv2.COLOR_BGR2GRAY)
    found, corners = cv2.findChessboardCorners(
        grayL, (BOARD_W, BOARD_H),
        cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE
    )
    if found:
        # refine corners
        corners = cv2.cornerSubPix(
            grayL, corners, (11,11), (-1,-1),
            (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        )
        src_pts = corners.reshape(-1, 2)
        dst_pts = np.array([
            [x * SQUARE_PX, y * SQUARE_PX]
            for y in range(BOARD_H)
            for x in range(BOARD_W)
        ], dtype=np.float32)
        H, _ = cv2.findHomography(src_pts, dst_pts)
        warp = cv2.warpPerspective(
            undistL, H, (BOARD_W * SQUARE_PX, BOARD_H * SQUARE_PX)
        )
    else:
        warp = np.zeros((BOARD_H * SQUARE_PX, BOARD_W * SQUARE_PX, 3), np.uint8)

    # 4) Layout for display
    top = cv2.hconcat([undistL, undistR])
    middle = cv2.hconcat([rectL, rectR])
    bottom = warp
    # Resize bottom to match width of top
    bottom = cv2.resize(bottom, (top.shape[1], bottom.shape[0] * top.shape[1] // warp.shape[1]))
    combined = cv2.vconcat([top, middle, bottom])

    cv2.imshow("Undistort vs Rectify vs Fronto-Parallel", combined)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Cleanup
capL.release()
capR.release()
cv2.destroyAllWindows()
